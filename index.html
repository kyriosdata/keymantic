<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="author" content="Fábio Nogueira de Lucena">
    <title>Keymantic</title>
    <meta name="description" content="Keymantic explicado. Tutorial sobre o método Keymantic."> 
    
    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
</script>
    <script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
  </head>
  <body style="font-size: 14pt;width:80%;margin-left: auto;margin-right: auto">
    <h1>Entendendo o keymantic...</h1>
    
    <h2>Definições</h2>
    
    <h4>Banco de dados</h4>
    <blockquote>Defina AQUI!</blockquote>
    
    <h4>Palavra-chave</h4>
      <blockquote><p>Uma palavra-chave é uma sequência de caracteres. Exemplos: <i>heart</i>, 
      a sigla <i>IMC</i>, o valor <i>1200</i> ou ainda <i>80mm/HG</i>.</p>
      
      <p>Observe que
      uma palavra-chave pode conter um ou mais espaços em branco e, nesse caso,
      a palavra-chave deve ser obrigatoriamente delimitada por aspas duplas. Por 
      exemplo, o nome próprio <i>"João Carlos"</i>, ou mesmo 
        <i>"80 mm/HG"</i>.</p>
    </blockquote>
    
    <h4>Conjunto de arquétipos</h4>
    <blockquote><p>Um conjunto de arquétipos $A = \{a_1, a_2, \ldots, a_n\}$ reúne zero ou
      mais arquétipos $a_i$, onde $0\lt i \leq n$ e $|A|=n$.</p>
    
      <p>Um arquétipo pode, ao longo do tempo, ser alterado, e cada versão de um
        arquétipo é tratada como um arquétipo distinto.</p>
    </blockquote>
    
    <h4>Consulta baseada em palavras-chave</h4>
    <blockquote>
      Uma consulta $q$ é uma sequência de palavras-chave, ou seja, 
    $q = (k_1,k_2,\ldots,k_j)$ onde $j$ é o total de palavras-chave da
    consulta. Adicionalmente a palavra-chave $k_m$ ocorre imediatamente após $k_{m-1}$ e 
    imediatamente antes de $k_{m+1}$ para $1\lt m\lt j$.
    </blockquote>
    
    <h4>Matriz de pesos</h4>
    <blockquote>Matriz bidimensional com uma linha para cada palavra-chave
    da consulta e uma coluna para cada termo do esquema???!!!
    </blockquote>
        
    <h4>Termo de esquema</h4>
    <blockquote>
      É uma operação, nome de tabele ou nome de coluna do esquema. Por exemplo, ...COMPLEMENTE AQUI.
    </blockquote>
    
    <h3>Termo de valor</h3>
    É um possível valor que pode estar presente em uma tupla do banco de dados. 
    
    <hr>
    
    <h2>O que é o Keymantic?</h2>
    Keymantic é um algoritmo que gera zero ou mais consultas em SQL a partir
    de um conjunto de palavras-chave de entrada e de um esquema.
    
    O processo de geração das consultas é dividido em passos. O restante deste texto tem o objetivo
    de explicar cada uma destas etapas. Antes, contudo, convém esclarecer a motivação para o trabalho.
    
    <h2>Por que o Keymantic é importante?</h2>
    As buscas com palavras-chave são a principal forma de pesquisa por informações na web. Contudo, apenas parte
    das informações podem ser recuperadas desta forma, dado que parte significativa dos dados estão armazenados
    em bancos de dados relacionais, para os quais o suporte para consultas por palavras-chave é limitado. O
    Keymantic é uma proposta para permitir a consulta em bancos de dados relacionais por meio de palavras-chave.
    
    <h2>Keymantic: cinco passos</h2>
    O algoritmo é dividido em cinco passos, que fazem uso de uma estrutura de dados comum, a matriz de pesos.  
    
    <h4> Pré-processamento</h4>
    Nesta etapa é feita a "limpeza" da consulta, ou seja, são removidas dela as palavras chaves que não possuem nenhum significado real
    na base de dados. Outra tarefa importante dessa fase é a segmentação da consulta de forma que palavras chaves que precisem estar
    juntas para manter seu significado sejam mapeadas como um unico termo. Esta fase é dividida em duas etapas: Verificação de
    função agregada/valores compostos/ordenação e Expansão da consulta.
    Esta é um fase de pré-processamento, ou seja, não é considerada um dos cinco passos do keymantic, mas sim uma fase de preparação
    da palavra da chave para facilitar o trabalho realizados nos passos verdadeiros.
    
     <h4> Cálculo dos pesos intrisecos de valor e de esquema</h4>
    Neste primeiro passo os termos existentes na pesquisa são mapeados através da matriz de pesos
    para indicar se aquele termo será interpretado como um termo de esquema ou de valor. O calculo desses
    pesos é feito a partir do uso de algoritmos especificos para esta tarefa.
    
    <h4> Seleção dos melhores mapeamentos para o termos de esquema</h4>
    Neste passo, a ferramenta keymantic utiliza uma versão modificada do algoritmo Hungarian para  gerar uma série de mapeamentos entre
    as palavras-chave e os termos de esquema da submatriz SW (a submatriz SW é o conjunto de colunas da matriz de pesos cujas
    colunas representam termos de esquema do banco de dados, por exemplo, o nome de um atributo de tabela).
    Para gerar um mapeamento, é identificado o maior peso de cada linha da tabela, a intesecção de cada linha (uma palavra-chave) com a
    coluna (um termo de esquema) onde está o valor máximo forma uma mapeamento entre palavras-chave e termos do banco de dados. Esse processo
    segue até que a quantidade de mapeamentos desejada seja gerada e sempre que um mapeamento é gerado os valores máximos caracterizados
    como máximos são
    removidos, para permitir a geração de um novo mapeamento entre palavras chave e mapeamentos diferentes. 
    O primeiro mapeamento é considerado melhor que o segundo, e cada mapeamento sequente é considerado melhor que o anterior.
    
    <h4> Seleção dos melhores mapeamentos para termos de valor </h4>
    Neste passo, para cada mapeamento gerado na passo anterior é gerado um mapeamento para os termos que não foram mapeados naquele
    mapeamento. Em outras palavras, queremos dizer que se em um mapeamento gerado no passo anterior uma ou mais palavras não foram
    mapeadas como termos de esquema, então elas serão mapeadas como termos de valor.  
    Esse mapeamento para termos de valor ocorre em duas etapas: na primeira etapa, os pesos dos termos são atualizados na submatriz
    VW (a submatriz VW é o conjunt de colunas da matriz de pesos cujas colunas representam termos de valor do banco de dados), de acordo
    com a proximidade entre as palavras-chave não mapeadas e as palavras-chave mapeadas para termos de esquema. O motivo para essa ação
    é que geralmente palavras-chave chave relacionadas em uma consulta são escritas proximas, uma da outra.
    Na segunda etapada, as palavras-chave que ainda não foram mapeadas, são mapeadas novamente por uma algoritmo adaptado do Hungarian,
    removendo desse mapeamento as palavras que já foram mapeadas para termos de esquema e aplicando um processo de contextualização que
    atualiza os pesos de cada palavra-chave na matriz SW de acordo com um conjunto de regras.
    
    <h5> Processo de Contextualização </h5>
    O processo de contextualização utiliza um conjunto de regras para modificar os pesos da termos na matriz VW (na verdade, a contex-
    tualização também é utilizada para a matriz SW quando duas palavras-chave são mapeadas para um mesmo termo de esquema.)
    No inicio do processo de contextualização (apenas para o passo três), todos os pesos e linhas da matriz VW correspondentes à palavras-chave que já foram 
    mapeadas para termos de esquema são definidos como zero, para garantir que elas não sejam mapeadas também como termos de valor.
    
    Outras três fazes completam o processo de contextualização e são aplicadas tanto no passo 2 quanto no passo 3.
    
    
    
    Na primeira fase, para cada palavra-chave K, que já foi mapeada para um termo de esquema, atribui-se um valor constante a todas as 
    demais palavras-chave entre K e a proxima palavra-chave S, mapeada para um termo de esquema. Essas palavras-chave entre K e S
    são chamadas de free trailing keywords.
    Todas as palavras-chave entre a cada palavra-chave K, que já foi mapeada para um termo de esquema e palavra chave J anterior,
    mapeada para um termo de esquema também recebem um valor constante. Essas palavras entre J e K recebem o nome de free preceding keywords.
    
    Na segunda fase é acrescentando um valor constante às free trailing keywords e free preceding keywords para termos que representem
    atributos da mesma relação que A. Ou seja, se alguma dessas palavras-chave estiver mapeada como um termo de valor para outra coluna
    da mesma tabela, é provavel que ela esteja relacionada a consulta como por exemplo, parte de uma cláusula where.
    
     Na terceira fase, novamente é acrescentando um valor constante às free trailing keywords e free preceding keywords de cada palavra-chave
    k mapeada para um atributo/coluna A cujos proprios atributos/colunas se relacionem a A através de um caminho de junção. É um principio
    àquele aplicado na segunda fase, porém entre tabelas diferentes de um banco de dados. 
    
    <h4> Geração das Configurações</h4>
    Neste passo, para cada mapeamento para termos de esquema I, e para cada mapeamento para termos de valor J, gerados nos passos anteriores
    é feita uma combinação IJ, chama de configuração. A pontuação de uma configuração é a soma da pontuação dos dois mampeamentos i, j que
    a formam.
    
    <h4> Geração das Interpretações</h4>
    Neste passo são geradas as interpretações para as configurações existentes. Cada interpretação consiste em uma consulta SQL.
    A keymantic utiliza uma abordagem gulosa para atender a todas as possibilides de interpretações quando existem caminhos de junção entre
    os termos da configuração.
    Para realizar essa abordagem, é construido um grafo onde cada nó representa um termo do banco de dados e uma aresta conceta esses nós
    se existe uma relação de chave primária e chave estrangeira entre seus termos.
    
    Data uma configuração, todos os termos que fazem parte desta configuração são marcados no grafo. Então é feita uma busca em largura para
    encontrar os caminhos que conectam estes termos. A consulta é então construida usando os termos marcados, de forma a colocar as tabelas
    na cláusula FROM, as condições de integridade referencial modeladas pela aresta na cláusula WHERE e os atributos na cláusula SELECT.
    
    
      <h2>Algumas limitações da Keymantic</h2>
    
    <ul>
      <li> Só é capaz de mapear uma palavra-chave para um único termo do banco de dados. </li>
       <li> Supõe que todas as palavras-chave de uma consulta representam algum termo do banco de dados. </li>
       <li> Não ordena as consultas SQL geradas. </li>
      
    </ul>
    
    
  </body>
</html>
